// TODO extract some formatting tests from this, maybe just as one huge file for simplicity

import std.types.[bool, int, uint, natural, any];
import std.math.[gcd, min, max];
import std.util.[print, assert];
import examples.axi_gearbox.axi_gearbox;
import examples.axi_stream.[axi_stream, axi_passthrough, axi_passthrough as _, axi_passthrough as _, axi_passthrough as _, axi_passthrough as _, axi_passthrough as _];

const input_width = [
    very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier,
    [very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier, very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier],
    [very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier, 4],
    f(very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier, very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier, f(4, a=5))
];


const output_width = very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier
    + very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier
    + very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier
    + very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier
    + very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier
    + very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier
        * very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier
    + very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier
        * very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier;


const something = ();
const something = (5,);
const something = (5,6,7,8);
const something = (very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier,very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier,7,8);

const very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier: very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier = very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier;
const a: very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier = very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier;
const very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier: a = very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier;
const very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier: very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier = a;

const output_width = very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier______________;
const output_width = very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier_______________;
const output_width = very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier________________;
const output_width = very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier_________________;

type x = very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier + very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier;
type x(n: uint) = 2**n;
type x(very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier: uint, very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier: bool) = false;

type x(type v = uint;type v = uint;if(false) {type v = uint;} n: v, c: d) = bool;
type x(type v = uint;type v = uint;if(false) {type v = uint;}else if(true) {} else {} n: v, c: d) = bool;

const { if(false) { const a = false; } }

const {
    if (very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier && very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier) {}
}

//const input_width: uint = 8;

//pub struct SomeVeryLongNameSomeVeryLongNameSomeVeryLongNameSomeVeryLongNameSomeVeryLongNameSomeVeryLongNameSomeVeryLongName {
//}

//import
//    a
//    .b
//    .c
//    .d
//    .[a, b, c];
//
//val a = 4
//    + 6
//    + 6
//    + 7



//const a = [1, 2, 3];
//const a = [1, 2, 3,];
//const a = [
//    1,
//    2,
//    3,
//];

//const a = [1, 2, 3/*test*/];

//const a = x + y + z;

// TODO should this care about operator precedence or not??
//   maybe flatten for ops with the same precedence, but nest for different precedence?
//const a =
//    x
//    + y * z;

// TODO fix empty enums
// TODO skip match arm checking for compile-time values
// TODO fix current crash, "Range must be valid, got 0..=-1", also related to empty enums
//pub module top ports(
//    clk: in clock,
//    rst: in async bool,
//
//    x: in sync(clk, rst) bool,
//    y: out sync(clk, rst) bool,
////    e: in sync(clk, rst) A,
//) {
//    reg out y = false;
//
//    clocked(clk, async rst) {
//        val a;
//        if (x) {
//            a = false;
//        } else {
//            a = false;
////            a = true;
//        }
//
//        y = a;
//    }
//}
//
//enum A {
//}
//
//enum Derp {
//    Yes,
//    No,
//    Maybe,
//}