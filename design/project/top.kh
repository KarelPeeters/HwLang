// TODO extract some formatting tests from this, maybe just as one huge file for simplicity

import std.types.[bool, int, uint, natural, any];
import std.math.[gcd, min, max];
import std.util.[print, assert];
import examples.axi_gearbox.axi_gearbox;
import examples.axi_stream.[axi_stream, axi_passthrough, axi_passthrough as _, axi_passthrough as _, axi_passthrough as _, axi_passthrough as _, axi_passthrough as _];

const input_width = [
    very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier,
    [very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier, very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier],
    [very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier, 4],
    f(very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier, very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier, f(4, a=5))
];


const output_width = very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier
    + very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier
    + very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier
    + very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier
    + very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier
    + very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier
        * very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier
    + very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier
        * very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier;


const something = ();
const something = (5,);
const something = (5,6,7,8);
const something = (very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier,very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier,7,8);

const very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier: very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier = very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier;
const a: very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier = very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier;
const very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier: a = very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier;
const very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier: very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier = a;

const output_width = very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier______________;
const output_width = very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier_______________;
const output_width = very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier________________;
const output_width = very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier_________________;

struct Point{x:int,y:int,}
struct GenericStruct(T:type,N:uint){data:T,size:uint(N),if(N>4){extra_field:bool,}}
enum Color{Red,Green,Blue(int),}
enum Result(T:type,E:type){Ok(T),Err(E),if(false){None,}}
fn add(a:int,b:int)->int{return a+b;}
fn generic_func(T:type,x:T,y:T)->T{if(true){return x;}else{return y;}}

type x = very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier + very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier;
type x(n: uint) = 2**n;
type x(very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier: uint, very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier: bool) = false;

type x(type v = uint;type v = uint;if(false) {type v = uint;} n: v, c: d) = bool;
type x(type v = uint;type v = uint;if(false) {type v = uint;}else if(true) {} else {} n: v, c: d) = bool;

const { if(false) { const a = false; } }

const {
    if (very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier && very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier) {}

    very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier += very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier;

    {
        [true, false];
    }

    match (false) {
        _ => {}
    }

    for (x in [1, 2, 3]) {}
    for (x: uint in [1, 2, 3]) {}
    for (
        x: uint
        in [very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier, very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier, 3]) {}

    while (true) {}
    while (
        very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier
            == very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier
    ) {}
}


external module foo(T: type) ports(x: in async T, y: out async T, if(false) { z: in async bool }
    d: in sync(
        very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier,
        very_long_identifier_very_long_identifier_very_long_identifier_very_long_identifier
    ) bool,
    d: interface async something,
    sync(clk, rst) {
        x: in bool,
        y: out bool,

        d: interface something,
    }
)

// TODO respect newline
//    also for extra list
interface my_interface {
    const WIDTH = 8;
    type data_type = uint(WIDTH);
    data: data_type,
    valid: bool,
    ready: bool,
    if (WIDTH > 4) {
        extra_signal: bool,
    }
    interface master {
        data: out,
        valid: out,
        ready: in,
        if (WIDTH > 4) {
            extra_signal: out,
        }
    }
    interface slave {
        data: in,
        valid: in,
        ready: out,
        if (WIDTH > 4) {
            extra_signal: in,
        }
    }
}

pub interface bus_interface(WIDTH: uint, very_long_parameter_name_that_will_cause_wrapping: bool) {
    const ADDR_WIDTH = WIDTH;
    type addr_type = uint(ADDR_WIDTH);
    addr: addr_type,
    data: uint(32),
    enable: bool,
    if (very_long_parameter_name_that_will_cause_wrapping) {
        debug_signal: bool,
    }
    interface master {
        addr: out,
        data: out,
        enable: out,
        if (very_long_parameter_name_that_will_cause_wrapping) {
            debug_signal: out,
        }
    }
}

interface foo {
//    interface master {}
//    interface slave {}
}

module test_module(WIDTH: uint) ports(
    clk: in clock,
    rst: in async bool,
    data_in: in sync(clk, rst) uint(WIDTH),
    data_out: out sync(clk, rst) uint(WIDTH),

    derp: in async bool,
    test: out async bool,
) {
    reg out test_marker=42;
    wire intermediate: sync(clk, rst) uint(WIDTH);
    reg counter: sync(clk, rst) uint = 0;
    
    if (WIDTH > 8) {
        wire extra_signal: sync(clk, rst) bool;
    }
    
    for (i in [0, 1, 2]) {
        wire data_bit: sync(clk, rst) bool;
    }
    
    comb {
        intermediate = data_in + 1;
        print(1);

        print(2);
    }
    
    clocked(clk, async rst) {
        counter += 1;
        if (counter > 10) {
            counter = 0;
        }
        data_out = intermediate;
    }
    
    instance some_sub_module ports(data=intermediate, enable=true);
}




//const input_width: uint = 8;

//pub struct SomeVeryLongNameSomeVeryLongNameSomeVeryLongNameSomeVeryLongNameSomeVeryLongNameSomeVeryLongNameSomeVeryLongName {
//}

//import
//    a
//    .b
//    .c
//    .d
//    .[a, b, c];
//
//val a = 4
//    + 6
//    + 6
//    + 7



//const a = [1, 2, 3];
//const a = [1, 2, 3,];
//const a = [
//    1,
//    2,
//    3,
//];

//const a = [1, 2, 3/*test*/];

//const a = x + y + z;

// TODO should this care about operator precedence or not??
//   maybe flatten for ops with the same precedence, but nest for different precedence?
//const a =
//    x
//    + y * z;

// TODO fix empty enums
// TODO skip match arm checking for compile-time values
// TODO fix current crash, "Range must be valid, got 0..=-1", also related to empty enums
//pub module top ports(
//    clk: in clock,
//    rst: in async bool,
//
//    x: in sync(clk, rst) bool,
//    y: out sync(clk, rst) bool,
////    e: in sync(clk, rst) A,
//) {
//    reg out y = false;
//
//    clocked(clk, async rst) {
//        val a;
//        if (x) {
//            a = false;
//        } else {
//            a = false;
////            a = true;
//        }
//
//        y = a;
//    }
//}
//
//enum A {
//}
//
//enum Derp {
//    Yes,
//    No,
//    Maybe,
//}
