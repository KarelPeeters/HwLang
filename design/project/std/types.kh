// TODO allow signature declarations for everything, even types!

// Basic types
// TODO bool should be an enum :)
type bool = __builtin_type("bool");

// TODO what is the difference if anything between "type" and "const" for types?
//const bool: type = __builtin_type();

//type my_array(T: type) = Array(T, n);
//function my_array(T: type) -> type {
//    return Array(T, n);
//}

// Signature overloading, even for types!
// TODO allow separate optional min and max? then uint is just int(0..)
// TODO is there a nice way to make "unsigned" the default?

// Usages:
// x: int -> infinitely sized
// x: int(0..), x: int(2..17) -> partially constrained halfopen ranges
// x: int(0..=7), x: int(..=8) -> partially constrained closed ranges
// x: uint -> simple alias for a positive integer
// TODO do we want to allow uint to take ranges?

// Utility
enum Option(T: type) {
    None,
    Some(T),
}

struct Range(L: type, H: type) {
    min: L,
    max: H,
}

// TODO add overloading?
type int_range(r: Range(Option(int), Option(int))) = __builtin_type("int_range", r);
// TODO can we write this as `int_range(..)` again?
type int = __builtin_type("int");
type uint = int_range(0..);
type int_bits(n: uint) = int_range(-2**(n - 1) .. 2**(n - 1));
type uint_bits(n: uint) = int_range(0 .. 2**n);

// Containers
//type List(T: type) = __builtin_type("List", T);
 // TODO "uint, *uint" or "+uint"? (for multidim arrays)
type Array(T: type, len: uint) = __builtin_type("Array", T, len);

type bits(n: Option(uint)) = __builtin_type("bits", n);

// Operators
// TODO move operators to different file
// TODO operator bodies? implement in std or in compiler?
// TODO allow multiline calculations for output type?
// operator "+"(
//     left: integer(left_range),
//     right: integer(right_range),
// ) -> integer() {
//
// }
