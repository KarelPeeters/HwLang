// TODO allow signature declarations for everything, even types!

// Basic types
// TODO bool should be an enum :)
type bool = __builtin_type();

// Signature overloading, even for types!
// TODO allow separate optional min and max? then uint is just int(0..)
// TODO is there a nice way to make "unsigned" the default?

// Usages:
// x: int -> infinitely sized
// x: int(0..), x: int(2..17) -> partially constrained halfopen ranges
// x: int(0..=7), x: int(..=8) -> partially constrained closed ranges
// x: uint -> simple alias for a positive integer
// TODO do we want to allow uint to take ranges?

enum Option(T: type) {
    None,
    Some(T),
}

struct Range(L: type, H: type) {
    min: L,
    max: H,
}

type int(r: Range(Option(int), Option(int))) = __builtin_type();
type int = int(..);
type uint = int(0..);
type int(n: uint) = int(-2**(n - 1) .. 2**(n - 1));
type uint(n: uint) = int(0 .. 2**n);

// Containers
type List(T: type) = __builtin_type();
 // TODO "uint, *uint" or "+uint"? (for multidim arrays)
type Array(T: type, len: uint) = __builtin_type();

type bits(n: Option(uint)) = __builtin_type();

// Utility
// TODO convert between these for unbounded types, eg. int/uint
struct Range(T: type) { min: T, max: T }
struct RangeInc(T: type) { min: T, max_inc: T }

// Operators
// TODO move operators to different file
// TODO operator bodies? implement in std or in compiler?
// TODO allow multiline calculations for output type?
// operator "+"(
//     left: integer(left_range),
//     right: integer(right_range),
// ) -> integer() {
//
// }
