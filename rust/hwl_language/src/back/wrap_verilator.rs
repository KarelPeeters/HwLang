use crate::front::bits::WrongType;
use crate::front::check::{TypeContainsReason, check_type_contains_value};
use crate::front::diagnostic::{DiagError, Diagnostics};
use crate::front::item::ElaborationArenas;
use crate::front::value::CompileValue;
use crate::mid::ir::{IrModule, IrModules, IrPort, IrPortInfo};
use crate::syntax::ast::PortDirection;
use crate::syntax::pos::Spanned;
use crate::util::arena::{Arena, IndexType};
use crate::util::big_int::BigUint;
use dlopen2::wrapper::{Container, WrapperApi};
use indexmap::IndexMap;
use itertools::{Either, Itertools, enumerate};
use num_integer::div_ceil;
use std::ffi::{CString, NulError, c_char, c_void};
use std::fmt::{Display, Formatter};
use std::path::Path;
use std::ptr::null;
use std::sync::Arc;

#[derive(Debug)]
pub enum VerilatorError {
    Library(dlopen2::Error),
    CheckFailed,
    ApiError(u8, &'static str),
    PortTooLarge(BigUint),
    InternalError(&'static str),
    SetOutputPort(String),
    PathContainsZeroByte,
}

impl Display for VerilatorError {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            VerilatorError::Library(err) => write!(f, "Library error: {err}"),
            VerilatorError::CheckFailed => write!(f, "Check failed, the library and IR modules don't match"),
            VerilatorError::ApiError(code, context) => write!(f, "API error {code} in context '{context}'"),
            VerilatorError::PortTooLarge(size) => write!(f, "Port size too large: {size} bits"),
            VerilatorError::InternalError(msg) => write!(f, "Internal error: {msg}"),
            VerilatorError::SetOutputPort(port) => write!(f, "Cannot set output port `{port}`"),
            VerilatorError::PathContainsZeroByte => write!(f, "Path cannot contain a zero byte"),
        }
    }
}

impl From<dlopen2::Error> for VerilatorError {
    fn from(err: dlopen2::Error) -> Self {
        VerilatorError::Library(err)
    }
}

#[derive(WrapperApi)]
struct VerilatedApi {
    check: unsafe extern "C" fn(arena_random: u16, top_module_index: usize) -> u8,
    create_instance: unsafe extern "C" fn(trace_path: *const c_char) -> *mut c_void,
    destroy_instance: unsafe extern "C" fn(instance: *mut c_void),
    save_trace: unsafe extern "C" fn(instance: *mut c_void),
    step: unsafe extern "C" fn(instance: *mut c_void, increment_time: u64) -> u8,
    get_port: unsafe extern "C" fn(instance: *mut c_void, port_index: usize, data_len: usize, data: *mut u8) -> u8,
    set_port: unsafe extern "C" fn(instance: *mut c_void, port_index: usize, data_len: usize, data: *const u8) -> u8,
}

// TODO rename
#[derive(Clone)]
pub struct VerilatedLib {
    lib: Arc<Container<VerilatedApi>>,

    ports: Arena<IrPort, IrPortInfo>,
    ports_named: IndexMap<String, IrPort>,
}

/// This struct is intentionally not [Send], see https://verilator.org/guide/latest/verilating.html#multithreading.
pub struct VerilatedInstance {
    lib: VerilatedLib,
    instance: *mut c_void,
}

// TODO think about and document safety
impl VerilatedLib {
    /// The loaded library at `path` must be a dynamic library compiled from:
    /// * the verilated verilog generated by [crate::back::lower_verilog::lower_to_verilog]
    /// * the wrapper C++ generated by [lower_verilator::lower_verilator]
    ///
    /// both generated from the same `modules` and `top_module`.
    ///
    /// # Safety
    /// The conditions above must be met, there is no runtime way to fully check for them.
    /// We only make a best-effort to check that the right functions are present in the library
    /// and that the same `modules` and `top_module` were used.
    pub unsafe fn new(modules: &IrModules, top_module: IrModule, path: &Path) -> Result<Self, VerilatorError> {
        let (lib, result) = unsafe {
            let lib: Container<VerilatedApi> = Container::load(path)?;
            let result = lib.check(modules.check().inner().get(), top_module.inner().index());
            (lib, result)
        };
        if result != 0 {
            return Err(VerilatorError::CheckFailed);
        }

        let top_info = &modules[top_module];
        let ports_named = top_info.ports.iter().map(|(p, info)| (info.name.clone(), p)).collect();
        Ok(Self {
            lib: Arc::new(lib),
            ports: top_info.ports.clone(),
            ports_named,
        })
    }

    pub fn instance(&self, trace_path: Option<&Path>) -> Result<VerilatedInstance, VerilatorError> {
        // convert path to C string pointer
        let trace_path_slot;
        let trace_path_ptr = match trace_path {
            None => null(),
            Some(path) => {
                let bytes = path.as_os_str().as_encoded_bytes();
                trace_path_slot = CString::new(bytes).map_err(|_: NulError| VerilatorError::PathContainsZeroByte)?;
                trace_path_slot.as_ptr()
            }
        };

        let instance = unsafe { self.lib.create_instance(trace_path_ptr) };
        Ok(VerilatedInstance {
            lib: self.clone(),
            instance,
        })
    }

    pub fn ports(&self) -> &Arena<IrPort, IrPortInfo> {
        &self.ports
    }

    pub fn ports_named(&self) -> &IndexMap<String, IrPort> {
        &self.ports_named
    }
}

impl Drop for VerilatedInstance {
    fn drop(&mut self) {
        let VerilatedInstance { lib, instance } = self;
        unsafe {
            lib.lib.destroy_instance(*instance);
        }
    }
}

// TODO make this a general trait that can be implemented for different simulation backends
impl VerilatedInstance {
    pub fn step(&mut self, increment_time: u64) -> Result<(), VerilatorError> {
        // TODO error if any port has never been set?
        unsafe { check_result(self.lib.lib.step(self.instance, increment_time), "step") }
    }

    pub fn save_trace(&mut self) {
        unsafe { self.lib.lib.save_trace(self.instance) }
    }

    pub fn ports(&self) -> &Arena<IrPort, IrPortInfo> {
        self.lib.ports()
    }

    pub fn ports_named(&self) -> &IndexMap<String, IrPort> {
        self.lib.ports_named()
    }

    pub fn get_port(&self, port: IrPort) -> Result<CompileValue, VerilatorError> {
        let port_info = &self.lib.ports()[port];

        let size_bits = usize::try_from(port_info.ty.size_bits()).map_err(VerilatorError::PortTooLarge)?;
        let size_bytes = port_size_bytes(size_bits);
        let mut buffer = vec![0u8; size_bytes];

        // zero-width ports don't exist in verilog, so don't try to access them
        if size_bits != 0 {
            unsafe {
                let result =
                    self.lib
                        .lib
                        .get_port(self.instance, port.inner().index(), size_bytes, buffer.as_mut_ptr());
                check_result(result, "get_port")?;
            }
        }

        let bits = (0..size_bits)
            .map(|i| (buffer[i / 8] >> (i % 8)) & 1 != 0)
            .collect_vec();

        let value = port_info
            .ty
            .value_from_bits(&bits)
            .map_err(|_: WrongType| VerilatorError::InternalError("from_bits failed"))?;

        Ok(value)
    }

    pub fn set_port(
        &mut self,
        diags: &Diagnostics,
        elab: &ElaborationArenas,
        port: IrPort,
        value: Spanned<&CompileValue>,
    ) -> Result<(), Either<VerilatorError, DiagError>> {
        let port_info = &self.lib.ports()[port];
        match port_info.direction {
            PortDirection::Input => {}
            PortDirection::Output => return Err(Either::Left(VerilatorError::SetOutputPort(port_info.name.clone()))),
        }

        let reason = TypeContainsReason::Assignment {
            span_target: port_info.debug_span,
            span_target_ty: port_info.debug_info_ty.span,
        };
        check_type_contains_value(diags, elab, reason, &port_info.ty.as_type_hw().as_type(), value)
            .map_err(Either::Right)?;

        let bits = port_info
            .ty
            .value_to_bits(value.inner)
            .map_err(|_: WrongType| Either::Left(VerilatorError::InternalError("to_bits failed")))?;

        let size_bits = bits.len();
        let size_bytes = port_size_bytes(size_bits);
        let mut buffer = vec![0u8; size_bytes];
        for (i, bit) in enumerate(bits) {
            if bit {
                buffer[i / 8] |= 1 << (i % 8);
            }
        }

        // zero-width ports don't exist in verilog, so don't try to access them
        if size_bits != 0 {
            unsafe {
                let result = self
                    .lib
                    .lib
                    .set_port(self.instance, port.inner().index(), size_bytes, buffer.as_ptr());
                check_result(result, "set_port").map_err(Either::Left)?;
            }
        }

        Ok(())
    }
}

fn port_size_bytes(size_bits: usize) -> usize {
    match size_bits {
        // empty ports, they don't actually exist in verilog
        0 => 0,
        // single word scalar ports
        1..=8 => 1,
        9..=16 => 2,
        17..=32 => 4,
        33..=64 => 8,
        // wide ports
        65.. => div_ceil(size_bits, 32) * 4,
    }
}

fn check_result(result: u8, context: &'static str) -> Result<(), VerilatorError> {
    if result != 0 {
        Err(VerilatorError::ApiError(result, context))
    } else {
        Ok(())
    }
}
