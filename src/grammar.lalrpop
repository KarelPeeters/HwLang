//use std::str::FromStr;
use crate::parse::ast::*;
use crate::parse::pos::*;

// TODO what does inline do?
grammar;

match {
    // Skip whitespace and comments
    r"\s*" => { },
    r"//[^\n\r]*[\n\r]*" => { }, // `// comment`
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { }, // `/* comment */`

    // pass everything else through
    _,
}

pub PackageContent: PackageContent = {
    Item* => PackageContent { items: <>, span: Span::dummy() }
}

// items
Item: Item = {
    "type" <id:Id> <params:MaybeParams<TypeParam>> <inner:("=" Expr)?> ";" =>
        Item::Type(ItemDefType { id, inner: inner.map(|(_, inner)| Box::new(inner)), params, span: Span::dummy() }),
    "struct" <id:Id> <params:MaybeParams<TypeParam>> "{" <fields: Separated<StructField, ",">> "}" =>
        Item::Struct(ItemDefStruct { id, params, fields, span: Span::dummy() }),
    "enum" <id:Id> <params:MaybeParams<TypeParam>> "{" <variants: Separated<EnumVariant, ",">> "}" =>
        Item::Enum(ItemDefEnum { id, variants, span: Span::dummy() }),
    "module" <id:Id> <params:MaybeParams<ModuleParam>> <body:Block> =>
        Item::Module(ItemDefModule { id, params, body, span: Span::dummy() }),
    // We only allow tightly-bounding expressions in the return type to avoid (formal) ambiguity.
   "function" <id:Id> <params:Params<FunctionParam>> <ret_ty: ("->" <ExprLevelCallNoStruct>)?> <body:Block> =>
       Item::Function(ItemDefFunction { id, params, ret_ty, body, span: Span::dummy() }),
}

EnumVariant: EnumVariant = {
    <id:Id> <params:MaybeParams<Expr>> => EnumVariant { id, params, span: Span::dummy() },
}

StructField: StructField = {
    <id:Id> ":" <ty:Expr> => StructField { id, ty, span: Span::dummy() },
}

Block: Block = {
    "{" <statements:Statement*> "}" => Block { statements, span: Span::dummy() },
}

Statement: Statement = {
    // declaration
    <kind:DeclarationKind> <id:MaybeId> <ty: (":" <Box<Expr>>)?> <init: ("=" <Box<Expr>>)?> ";" => {
        Statement { kind: StatementKind::Declaration(Declaration {
            kind, id, ty, init, span: Span::dummy(),
        }), span: Span::dummy() }
    },
    // assignment
    <target:Box<Expr>> <op:AssignOp> <value:Box<Expr>> ";" => {
        let assignment = Assignment { op, target, value, span: Span::dummy() };
        Statement { kind: StatementKind::Assignment(assignment), span: Span::dummy() }
    },
    // expression
    // TODO semicolon is optional for control flow statements and the last expression in a block
    <Box<Expr>> ";" => Statement { kind: StatementKind::Expression(<>), span: Span::dummy() },
}

DeclarationKind: DeclarationKind = {
    "const" => DeclarationKind::Const,
    "val" => DeclarationKind::Val,
    "var" => DeclarationKind::Var,
}

// parameters
MaybeParams<P>: Params<P> = {
    Params<P>,
    => Params { params: vec![], span: Span::dummy() }
}

Params<P>: Params<P> = {
    "(" <Separated<P, ",">> ")" => Params { params: <>, span: Span::dummy() },
}

TypeParam: TypeParam = {
    <id:(<Id> ":")?> <ty:Expr> => TypeParam { id, ty, span: Span::dummy() },
}

FunctionParam: FunctionParam = {
    <cst:"const"?> <id:Id> ":" <ty:Expr> => FunctionParam { is_const: cst.is_some(), id, ty, span: Span::dummy() },
}

ModuleParam: ModuleParam = {
    <kind:ModuleParamKind> <id:Id> ":" <ty:Expr> => ModuleParam { kind, id, ty, span: Span::dummy() },
}

ModuleParamKind: ModuleParamKind = {
    "const" => ModuleParamKind::Const,
    "input" => ModuleParamKind::Input,
    "output" => ModuleParamKind::Output,
}

// expressions
Expr: Expression = ExprLevelReturn;

ExprLevelReturn: Expression = {
    "return" <value:Box<Expr>?> => Expression { kind: ExpressionKind::Return(value), span: Span::dummy() },
    "break" <value:Box<Expr>?> => Expression { kind: ExpressionKind::Break(value), span: Span::dummy() },
    "continue" => Expression { kind: ExpressionKind::Continue, span: Span::dummy() },
    ExprLevelRange,
}

ExprLevelRange: Expression = {
    // assoc none
    <left: ExprLevelLogical> ".." <right: ExprLevelLogical> => build_binary_op(BinaryOp::Range, left, right),
    <left: ExprLevelLogical> "..=" <right: ExprLevelLogical> => build_binary_op(BinaryOp::RangeInclusive, left, right),
    ExprLevelLogical,
}

ExprLevelLogical: Expression = {
    // assoc left, no mixing
    <left: ExprLevelLogicalAnd> "&&" <right: ExprLevelEqual> => build_binary_op(BinaryOp::BoolAnd, left, right),
    <left: ExprLevelLogicalOr> "||" <right: ExprLevelEqual> => build_binary_op(BinaryOp::BoolOr, left, right),
    ExprLevelEqual,
}
ExprLevelLogicalAnd: Expression = {
    <left: ExprLevelLogicalAnd> "&&" <right: ExprLevelEqual> => build_binary_op(BinaryOp::BoolAnd, left, right),
    ExprLevelEqual,
}
ExprLevelLogicalOr: Expression = {
    <left: ExprLevelLogicalOr> "||" <right: ExprLevelEqual> => build_binary_op(BinaryOp::BoolOr, left, right),
    ExprLevelEqual,
}

ExprLevelEqual: Expression = {
    // assoc none
    <left: ExprLevelBitWise> "==" <right: ExprLevelBitWise> => build_binary_op(BinaryOp::CmpEq, left, right),
    <left: ExprLevelBitWise> "!=" <right: ExprLevelBitWise> => build_binary_op(BinaryOp::CmpNeq, left, right),
    <left: ExprLevelBitWise> ">=" <right: ExprLevelBitWise> => build_binary_op(BinaryOp::CmpGte, left, right),
    <left: ExprLevelBitWise> ">" <right: ExprLevelBitWise> => build_binary_op(BinaryOp::CmpGt, left, right),
    <left: ExprLevelBitWise> "<=" <right: ExprLevelBitWise> => build_binary_op(BinaryOp::CmpLte, left, right),
    <left: ExprLevelBitWise> "<" <right: ExprLevelBitWise> => build_binary_op(BinaryOp::CmpLt, left, right),
    ExprLevelBitWise,
}

ExprLevelBitWise: Expression = {
    // assoc left
    <left: ExprLevelBitWise> "&" <right: ExprLevelShift> => build_binary_op(BinaryOp::BitAnd, left, right),
    <left: ExprLevelBitWise> "^" <right: ExprLevelShift> => build_binary_op(BinaryOp::BitXor, left, right),
    <left: ExprLevelBitWise> "|" <right: ExprLevelShift> => build_binary_op(BinaryOp::BitOr, left, right),
    ExprLevelShift,
}

ExprLevelShift: Expression = {
    // assoc none
    <left: ExprLevelAdd> "<<" <right: ExprLevelAdd> => build_binary_op(BinaryOp::Shl, left, right),
    <left: ExprLevelAdd> ">>" <right: ExprLevelAdd> => build_binary_op(BinaryOp::Shr, left, right),
    ExprLevelAdd,
}

ExprLevelAdd: Expression = {
    // assoc left
    <left: ExprLevelAdd> "+" <right: ExprLevelMul> => build_binary_op(BinaryOp::Add, left, right),
    <left: ExprLevelAdd> "-" <right: ExprLevelMul> => build_binary_op(BinaryOp::Sub, left, right),
    ExprLevelMul,
}

ExprLevelMul: Expression = {
    // assoc left
    <left: ExprLevelMul> "*" <right: ExprLevelUnary> => build_binary_op(BinaryOp::Mul, left, right),
    <left: ExprLevelMul> "/" <right: ExprLevelUnary> => build_binary_op(BinaryOp::Div, left, right),
    // TODO disallow mixing this with mul and/or div?
    <left: ExprLevelMul> "%" <right: ExprLevelUnary> => build_binary_op(BinaryOp::Mod, left, right),
    ExprLevelUnary,
}

ExprLevelUnary: Expression = {
    "!" <inner:Box<ExprLevelPower>> => Expression { kind: ExpressionKind::UnaryOp(UnaryOp::Not, inner), span: Span::dummy() },
    "-" <inner:Box<ExprLevelPower>> => Expression { kind: ExpressionKind::UnaryOp(UnaryOp::Neg, inner), span: Span::dummy() },
    ExprLevelPower,
}

ExprLevelPower: Expression = {
    // assoc none
    <left: ExprLevelCall> "**" <right: ExprLevelCall> => build_binary_op(BinaryOp::Pow, left, right),
    ExprLevelCall,
}

ExprLevelCall = ExprLevelCallGeneric<ExprLevelStructInit>;
ExprLevelCallNoStruct = ExprLevelCallGeneric<ExprLevelAtomic>;

ExprLevelCallGeneric<AtomicInner>: Expression = {
    <target:Box<ExprLevelDotIndex<AtomicInner>>> "(" <args:CallArgs> ")" =>
        Expression { kind: ExpressionKind::Call(target, args), span: Span::dummy() },
    <target:Box<ExprLevelDotIndex<AtomicInner>>> "[" <args:CallArgs> "]" =>
        Expression { kind: ExpressionKind::ArrayIndex(target, args), span: Span::dummy() },
    ExprLevelDotIndex<AtomicInner>,
}

CallArgs: Args = {
    // TODO support named args
    <positional:Separated<Expr, ",">> =>
        Args { positional, named: vec![], span: Span::dummy() },
}

ExprLevelDotIndex<AtomicInner>: Expression = {
    // assoc left
    <target: Box<ExprLevelDotIndex<AtomicInner>>> "." <index: Id> => Expression { kind: ExpressionKind::DotIdIndex(target, index), span: Span::dummy() },
    <target: Box<ExprLevelDotIndex<AtomicInner>>> "." <index: r"[0-9]+"> => {
        let index = Spanned { span: Span::dummy(), inner: index.parse().unwrap() };
        Expression { kind: ExpressionKind::DotIntIndex(target, index), span: Span::dummy() }
    },
    ExprLevelStructureInit<AtomicInner>,
}

ExprLevelStructureInit<AtomicInner>: Expression = {
    // initializers
    //  tuples
    "(" <values:SeparatedAtLeastOneSep<Expr, ",">> ")" => Expression { kind: ExpressionKind::TupleLiteral(values), span: Span::dummy() },
    //  array
    "[" <elements:Separated<Expr, ",">> "]" => Expression { kind: ExpressionKind::ArrayLiteral(elements), span: Span::dummy() },
    AtomicInner,
}

ExprLevelStructInit: Expression = {
    //  struct
    // TODO allow struct type params?
//    <struct_ty:Id> "{" "}" => todo!(),
    <struct_ty:ExprLevelCall> "{" <fields:Separated<StructLiteralField, ",">> "}" => todo!(),
//        Expression { kind: ExpressionKind::StructLiteral(StructLiteral { struct_ty, fields }), span: Span::dummy() },
    ExprLevelAtomic,
}

StructLiteralField: StructLiteralField = {
    <id:Id> ":" <value:Expr> => StructLiteralField { id, value, span: Span::dummy() },
}

ExprLevelAtomic: Expression = {
    // parentheses
    "(" <expr:Expr> ")" => expr,
    // block
    <block:Block> => Expression { kind: ExpressionKind::Block(block), span: Span::dummy() },
    // path
    Path => Expression { kind: ExpressionKind::Path(<>), span: Span::dummy() },
    // special case TODO why does this not get parsed as an identifier?
    "type" => Expression { kind: ExpressionKind::Type, span: Span::dummy() },
    // literals
    "true" => Expression { kind: ExpressionKind::BoolLiteral(true), span: Span::dummy() },
    "false" => Expression { kind: ExpressionKind::BoolLiteral(false), span: Span::dummy() },
    r"0x[0-9a-fA-F_]+" => Expression { kind: ExpressionKind::IntPattern(IntPattern::Hex(<>.to_owned())), span: Span::dummy() },
    r"0b[0-9a-fA-F_]+" => Expression { kind: ExpressionKind::IntPattern(IntPattern::Bin(<>.to_owned())), span: Span::dummy() },
    r"[0-9]+" => Expression { kind: ExpressionKind::IntPattern(IntPattern::Dec(<>.to_owned())), span: Span::dummy() },

    // control flow
    ExprControlFlow,
}

ExprControlFlow: Expression = {
    // if
    "if" "(" <cond:Box<Expr>> ")" <then_block:Block> <else_if_pairs:ElseIfPair*> <else_block:("else" <Block>)?> =>
        Expression { kind: ExpressionKind::If(IfExpression {
            cond, then_block, else_if_pairs, else_block
        }), span: Span::dummy() },
    // loop
    "loop" <body:Block> =>
        Expression { kind: ExpressionKind::Loop(LoopExpression { body }), span: Span::dummy() },
    // for
    "for" "(" <index:MaybeId> <index_ty: (":" <Box<Expr>>)?> "in" <iter:Box<Expr>> ")" <body:Block> =>
        Expression { kind: ExpressionKind::For(ForExpression { index, index_ty, iter, body }), span: Span::dummy() },
    // while
    "while" "(" <cond:Box<Expr>> ")" <body:Block> =>
        Expression { kind: ExpressionKind::While(WhileExpression { cond, body }), span: Span::dummy() },
}

Path: Path = {
    <parents: (<Id> "::")*> <id: Id> => Path { span: Span::dummy(), parents, id }
}

ElseIfPair: ElseIfPair = {
    "else" "if" "(" <cond:Box<Expr>> ")" <block:Block> => ElseIfPair { cond, block, span: Span::dummy() },
}

// terminals
Id: Identifier = {
    r"(_[a-zA-Z_0-9]+)|([a-zA-Z][a-zA-Z_0-9]*)" => Identifier { string: <>.to_owned(), span: Span::dummy() },
}

MaybeId: MaybeIdentifier = {
    "_" => MaybeIdentifier::Placeholder(Span::dummy()),
    Id => MaybeIdentifier::Identifier(<>),
}

AssignOp: Option<BinaryOp> = {
    "=" => None,
    "+=" => Some(BinaryOp::Add),
    "-=" => Some(BinaryOp::Sub),
    "*=" => Some(BinaryOp::Mul),
    "/=" => Some(BinaryOp::Div),
    "%=" => Some(BinaryOp::Mod),
    "&=" => Some(BinaryOp::BitAnd),
    "^=" => Some(BinaryOp::BitXor),
    "|=" => Some(BinaryOp::BitOr),
}

// utilities
Separated<T, S>: Vec<T> = { // (1)
    <mut v:(<T> S)*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

SeparatedAtLeastOneSep<T, S>: Vec<T> = { // (1)
    <mut v:(<T> S)+> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

Box<T>: Box<T> = {
    T => Box::new(<>),
}